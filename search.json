[{"path":"https://bbuchsbaum.github.io/fmriAR/CLAUDE.html","id":null,"dir":"","previous_headings":"","what":"CLAUDE.md","title":"CLAUDE.md","text":"file provides guidance Claude Code (claude.ai/code) working code repository.","code":""},{"path":"https://bbuchsbaum.github.io/fmriAR/CLAUDE.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"CLAUDE.md","text":"fmriAR R package provides fast AR/ARMA prewhitening fMRI design data matrices. uses C++ (via Rcpp RcppArmadillo) performance-critical computations.","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/fmriAR/CLAUDE.html","id":"build-and-load","dir":"","previous_headings":"Development Commands","what":"Build and Load","title":"CLAUDE.md","text":"","code":"# Compile C++ attributes Rcpp::compileAttributes()  # Generate documentation devtools::document()  # Load package for development devtools::load_all()"},{"path":"https://bbuchsbaum.github.io/fmriAR/CLAUDE.html","id":"testing","dir":"","previous_headings":"Development Commands","what":"Testing","title":"CLAUDE.md","text":"","code":"# Run all tests devtools::test()  # Run specific test file testthat::test_file(\"tests/testthat/test-whitening.R\")"},{"path":"https://bbuchsbaum.github.io/fmriAR/CLAUDE.html","id":"package-check","dir":"","previous_headings":"Development Commands","what":"Package Check","title":"CLAUDE.md","text":"","code":"# Full R CMD check devtools::check()"},{"path":[]},{"path":"https://bbuchsbaum.github.io/fmriAR/CLAUDE.html","id":"core-components","dir":"","previous_headings":"Architecture","what":"Core Components","title":"CLAUDE.md","text":"fit_noise(): Estimates AR/ARMA parameters residuals Supports run-aware censor-aware fitting Auto-selects model order p = \"auto\" Pooling options: “global”, “run”, “none” whiten_apply(): Applies prewhitening transformation design matrix X data Y Returns whitened versions suitable standard linear model fitting Handles multi-run fMRI data proper boundary conditions arma_whiten_inplace(): Core whitening implementation using RcppArmadillo OpenMP support (optional) parallel processing -place operations memory efficiency sandwich_from_whitened_resid() (R/sandwich.R): Computes robust standard errors acorr_diagnostics() (R/acorr.R): Autocorrelation diagnostics residuals pacf_cpp() (R/pacf_helpers.R): Partial autocorrelation computations","code":""},{"path":"https://bbuchsbaum.github.io/fmriAR/CLAUDE.html","id":"typical-workflow","dir":"","previous_headings":"Architecture","what":"Typical Workflow","title":"CLAUDE.md","text":"package designed specific fMRI preprocessing workflow: Fit initial OLS model get residuals Estimate noise model residuals using fit_noise() Apply whitening design matrix data using whiten_apply() Fit final model whitened data Compute robust standard errors diagnostics","code":""},{"path":"https://bbuchsbaum.github.io/fmriAR/CLAUDE.html","id":"build-requirements","dir":"","previous_headings":"","what":"Build Requirements","title":"CLAUDE.md","text":"R >= 4.0 C++14 compiler RcppArmadillo (linked automatically) Optional: OpenMP support (uncomment src/Makevars parallel processing)","code":""},{"path":"https://bbuchsbaum.github.io/fmriAR/articles/fmriAR-introduction.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Getting Started with fmriAR","text":"fmriAR provides lightweight tools estimating autoregressive (AR) autoregressive–moving-average (ARMA) noise models fMRI residuals applying matched prewhitening design matrices voxel-wise data. C++ core keeps large-scale whitening fast, R interface stays compact flexible. vignette walks typical workflow: Fit AR model residuals initial OLS regression. Apply run-aware prewhitening design data matrices. Inspect innovations verify whitening quality. Optionally pool information across parcels multiscale shrinkage helpers. Fit ARMA model residuals exhibit MA structure.","code":""},{"path":"https://bbuchsbaum.github.io/fmriAR/articles/fmriAR-introduction.html","id":"simulating-data-for-the-examples","dir":"Articles","previous_headings":"","what":"Simulating data for the examples","title":"Getting Started with fmriAR","text":"make examples reproducible, simulate modest fMRI-style dataset two runs, small design matrix, voxel-specific AR(2) noise.","code":"library(fmriAR) set.seed(42)  n_time <- 240 n_vox <- 60 runs <- rep(1:2, each = n_time / 2)  # Design matrix: intercept + task regressor X <- cbind(   intercept = 1,   task = rep(c(rep(0, 30), rep(1, 30)), length.out = n_time) )  # Generate voxel time-series with AR(2) noise phi_true <- matrix(0, nrow = n_vox, ncol = 2) phi_true[, 1] <- 0.5 + rnorm(n_vox, sd = 0.05) phi_true[, 2] <- -0.2 + rnorm(n_vox, sd = 0.05)  Y <- matrix(0, n_time, n_vox) innov <- matrix(rnorm(n_time * n_vox, sd = 1), n_time, n_vox) for (v in seq_len(n_vox)) {   for (t in seq_len(n_time)) {     ar_part <- 0     if (t > 1) ar_part <- ar_part + phi_true[v, 1] * Y[t - 1, v]     if (t > 2) ar_part <- ar_part + phi_true[v, 2] * Y[t - 2, v]     Y[t, v] <- ar_part + innov[t, v]   } }  # Add task signal to half the voxels beta <- c(0, 1.5) Y_signal <- drop(X %*% beta) Y[, 1:30] <- sweep(Y[, 1:30], 1, Y_signal, \"+\")  # Residuals from initial OLS fit coeff_ols <- qr.solve(X, Y) resid <- Y - X %*% coeff_ols"},{"path":"https://bbuchsbaum.github.io/fmriAR/articles/fmriAR-introduction.html","id":"fitting-an-ar-model","dir":"Articles","previous_headings":"","what":"Fitting an AR model","title":"Getting Started with fmriAR","text":"primary entry point fit_noise(). method = \"ar\" p = \"auto\", function selects AR order per run using BIC, enforces stationarity. returned fmriAR_plan holds run-specific AR coefficients metadata estimation procedure.","code":"plan_ar <- fit_noise(   resid,   runs = runs,   method = \"ar\",   p = \"auto\",   p_max = 6,   exact_first = \"ar1\",   pooling = \"run\" )  plan_ar # fmriAR whitening plan #   Method: AR #   Orders: p = 2, q = 0 #   Pooling: run #   Runs: 2 (1, 2) #   Exact first-sample scaling: AR(1) #   Coefficients: #     1: phi = 0.485, -0.193 #     2: phi = 0.482, -0.196"},{"path":"https://bbuchsbaum.github.io/fmriAR/articles/fmriAR-introduction.html","id":"whitening-design-and-data-matrices","dir":"Articles","previous_headings":"","what":"Whitening design and data matrices","title":"Getting Started with fmriAR","text":"whiten_apply() takes plan, design matrix, observed data returns whitened versions can used GLS estimation downstream analyses. default function returns whitened X Y. can compute GLS coefficients single linear solve:","code":"whitened <- whiten_apply(plan_ar, X, Y, runs = runs) str(whitened) # List of 2 #  $ X: num [1:240, 1:2] 1 0.515 0.708 0.708 0.708 ... #   ..- attr(*, \"dimnames\")=List of 2 #   .. ..$ : NULL #   .. ..$ : chr [1:2] \"intercept\" \"task\" #  $ Y: num [1:240, 1:60] -1.4936 -1.5949 -0.0306 -1.0101 -0.0617 ... Xw <- whitened$X Yw <- whitened$Y beta_gls <- qr.solve(Xw, Yw[, 1:5]) beta_gls #                 [,1]       [,2]        [,3]       [,4]       [,5] # intercept -0.1785576 0.03768029 -0.04137929 0.08983252 0.03839622 # task       1.6659992 1.38144408  1.18152789 1.45707478 1.53914426"},{"path":"https://bbuchsbaum.github.io/fmriAR/articles/fmriAR-introduction.html","id":"inspecting-innovations","dir":"Articles","previous_headings":"","what":"Inspecting innovations","title":"Getting Started with fmriAR","text":"whitened residuals (innovations) look close white noise. helper computes average absolute autocorrelation across voxels. comparison, calculation pre-whitened residuals typically much larger. simulation mean absolute autocorrelation lags 1–5 drops several fold whitening; exact values vary random seed, whitened summary markedly smaller raw baseline.","code":"innov_var <- Yw - Xw %*% qr.solve(Xw, Yw) lag_stats <- apply(innov_var, 2, function(y) {   ac <- acf(y, plot = FALSE, lag.max = 5)$acf[-1]   mean(abs(ac)) }) mean(lag_stats) # [1] 0.05721336 lag_stats_raw <- apply(resid, 2, function(y) {   ac <- acf(y, plot = FALSE, lag.max = 5)$acf[-1]   mean(abs(ac)) }) mean(lag_stats_raw) # [1] 0.140151"},{"path":"https://bbuchsbaum.github.io/fmriAR/articles/fmriAR-introduction.html","id":"parcel-pooling-and-multiscale-shrinkage","dir":"Articles","previous_headings":"","what":"Parcel pooling and multiscale shrinkage","title":"Getting Started with fmriAR","text":"per-voxel residuals noisy, can pool information across parcels. example constructs synthetic parcels uses multiscale PACF-weighted shrinkage. hood, fit_noise(..., pooling = \"parcel\") builds parcel-level mean residual series one spatial resolutions (fine/medium/coarse). parcel’s AR model estimated run-aware autocovariances, coefficients shrunk toward parents combining either partial autocorrelations (“pacf_weighted”) autocovariance functions (“acvf_pooled”). weights depend parcel size, dispersion across voxels, number runs, larger homogeneous parcels lend stability descendants preserving stationarity final per-parcel filters. parcel pooling requested, whiten_apply() returns X_by, list whitened design matrices per parcel, along voxel-wise Y innovations.","code":"parcels_fine <- rep(1:12, each = n_vox / 12) parcels_medium <- rep(1:6, each = n_vox / 6) parcels_coarse <- rep(1:3, each = n_vox / 3)  plan_parcel <- fit_noise(   resid,   runs = runs,   method = \"ar\",   p = \"auto\",   p_max = 6,   pooling = \"parcel\",   parcels = parcels_fine,   parcel_sets = list(     fine = parcels_fine,     medium = parcels_medium,     coarse = parcels_coarse   ),   multiscale = \"pacf_weighted\" )  plan_parcel$order # p q  # 6 0 whitened_parcel <- whiten_apply(plan_parcel, X, Y, runs = runs, parcels = parcels_fine) length(whitened_parcel$X_by) # [1] 12"},{"path":"https://bbuchsbaum.github.io/fmriAR/articles/fmriAR-introduction.html","id":"fitting-arma-models","dir":"Articles","previous_headings":"","what":"Fitting ARMA models","title":"Getting Started with fmriAR","text":"datasets require ARMA models capture remaining MA structure. workflow mirrors AR case sets method = \"arma\" supplies orders (p, q). ARMA whitening uses whiten_apply() interface.","code":"plan_arma <- fit_noise(   resid,   runs = runs,   method = \"arma\",   p = 2,   q = 1,   hr_iter = 1 )  plan_arma$order # p q  # 2 1 whitened_arma <- whiten_apply(plan_arma, X, Y, runs = runs) whitened_arma$X[1:5, ] #      intercept task # [1,] 1.0000000    0 # [2,] 0.4657323    0 # [3,] 0.5693939    0 # [4,] 0.6397975    0 # [5,] 0.6876133    0"},{"path":"https://bbuchsbaum.github.io/fmriAR/articles/fmriAR-introduction.html","id":"diagnostics-and-sandwich-estimates","dir":"Articles","previous_headings":"","what":"Diagnostics and sandwich estimates","title":"Getting Started with fmriAR","text":"package includes helpers quick diagnostics variance estimation:","code":"# Autocorrelation diagnostics for whitened residuals acorr <- acorr_diagnostics(Yw[, 1:3]) acorr # $lags #  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 #  # $acf #  [1]  0.392581599  0.360973704  0.310315389  0.322265370  0.374991747 #  [6]  0.210502166  0.223249048  0.235552972  0.217492041  0.143651583 # [11]  0.100407607  0.025318410  0.070841147  0.056705121  0.030469542 # [16]  0.010908172  0.003657289 -0.015876436 -0.048598733 -0.084495619 #  # $ci # [1] 0.1265175  # Sandwich standard errors from whitened residuals sandwich <- sandwich_from_whitened_resid(whitened$X, whitened$Y[, 1:3]) sandwich$se #           [,1]      [,2]      [,3] # [1,] 0.1161948 0.1309954 0.1219902 # [2,] 0.1629742 0.1837334 0.1711027"},{"path":"https://bbuchsbaum.github.io/fmriAR/articles/fmriAR-introduction.html","id":"next-steps","dir":"Articles","previous_headings":"","what":"Next steps","title":"Getting Started with fmriAR","text":"Explore test suite tests/testthat additional usage patterns, including multiscale pooling ARMA recovery checks. Inspect exported fmriAR_plan object plan_info() see per-run per-parcel coefficients. Combine whiten_apply() GLS modelling packages build end--end prewhitened analyses. production usage, consider benchmarking acquisition parameters reviewing package README tuning options thread control censor handling.","code":""},{"path":"https://bbuchsbaum.github.io/fmriAR/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Name. Author, maintainer.","code":""},{"path":"https://bbuchsbaum.github.io/fmriAR/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Name Y (2025). fmriAR: Fast AR/ARMA Prewhitening fMRI Design Data. R package version 0.0.0.9000, https://bbuchsbaum.github.io/fmriAR/.","code":"@Manual{,   title = {fmriAR: Fast AR/ARMA Prewhitening for fMRI Design and Data},   author = {Your Name},   year = {2025},   note = {R package version 0.0.0.9000},   url = {https://bbuchsbaum.github.io/fmriAR/}, }"},{"path":"https://bbuchsbaum.github.io/fmriAR/index.html","id":"fmriar","dir":"","previous_headings":"","what":"Fast AR/ARMA Prewhitening for fMRI Design and Data","title":"Fast AR/ARMA Prewhitening for fMRI Design and Data","text":"fmriAR provides fast AR/ARMA-based prewhitening fMRI GLM workflows. estimates voxel-wise parcel-based noise models, applies segment-aware whitening, exposes diagnostics make easy confirm residual independence.","code":""},{"path":"https://bbuchsbaum.github.io/fmriAR/index.html","id":"key-capabilities","dir":"","previous_headings":"","what":"Key capabilities","title":"Fast AR/ARMA Prewhitening for fMRI Design and Data","text":"Automatic AR/ARMA order selection via Hannan–Rissanen initialization iterative refinement Segment-aware whitening respects run boundaries optional multiscale pooling across parcels Convenience helpers whiten design matrices, refit GLMs, inspect autocorrelation diagnostics","code":""},{"path":"https://bbuchsbaum.github.io/fmriAR/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Fast AR/ARMA Prewhitening for fMRI Design and Data","text":"local development can load package devtools:","code":"# install.packages(\"remotes\")  # only needed once remotes::install_github(\"bbuchsbaum/fmriAR\") devtools::document() devtools::load_all()"},{"path":"https://bbuchsbaum.github.io/fmriAR/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick start","title":"Fast AR/ARMA Prewhitening for fMRI Design and Data","text":"See vignettes/ ?fit_noise detailed workflows, including multiscale pooling ARMA whitening.","code":"# X: design matrix (n x p), Y: voxel data (n x v), runs: factor or integer run labels res   <- Y - X %*% qr.solve(X, Y)                      # pre-fit residuals plan  <- fit_noise(res, runs = runs, method = \"ar\",    # estimate AR model                    p = \"auto\", pooling = \"global\") xyw   <- whiten_apply(plan, X, Y, runs = runs)         # whiten design and data fit   <- lm.fit(xyw$X, xyw$Y) se    <- sandwich_from_whitened_resid(xyw$X, xyw$Y, beta = fit$coefficients) ac    <- acorr_diagnostics(xyw$Y - xyw$X %*% fit$coefficients)"},{"path":"https://bbuchsbaum.github.io/fmriAR/reference/acorr_diagnostics.html","id":null,"dir":"Reference","previous_headings":"","what":"Autocorrelation diagnostics for residuals — acorr_diagnostics","title":"Autocorrelation diagnostics for residuals — acorr_diagnostics","text":"Autocorrelation diagnostics residuals","code":""},{"path":"https://bbuchsbaum.github.io/fmriAR/reference/acorr_diagnostics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Autocorrelation diagnostics for residuals — acorr_diagnostics","text":"","code":"acorr_diagnostics(   resid,   runs = NULL,   max_lag = 20L,   aggregate = c(\"mean\", \"median\", \"none\") )"},{"path":"https://bbuchsbaum.github.io/fmriAR/reference/acorr_diagnostics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Autocorrelation diagnostics for residuals — acorr_diagnostics","text":"resid Numeric matrix (time x voxels), typically whitened residuals. runs Optional run labels. max_lag Maximum lag evaluate. aggregate Aggregation across voxels: \"mean\", \"median\", \"none\".","code":""},{"path":"https://bbuchsbaum.github.io/fmriAR/reference/acorr_diagnostics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Autocorrelation diagnostics for residuals — acorr_diagnostics","text":"List autocorrelation values nominal confidence interval.","code":""},{"path":"https://bbuchsbaum.github.io/fmriAR/reference/acorr_diagnostics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Autocorrelation diagnostics for residuals — acorr_diagnostics","text":"","code":"# Generate example residuals with some autocorrelation n_time <- 200 n_voxels <- 50 resid <- matrix(rnorm(n_time * n_voxels), n_time, n_voxels)  # Add some AR(1) structure for (v in 1:n_voxels) {   resid[, v] <- filter(resid[, v], filter = 0.3, method = \"recursive\") }  # Check autocorrelation acorr_check <- acorr_diagnostics(resid, max_lag = 10, aggregate = \"mean\")  # Examine lag-1 autocorrelation lag1_acorr <- acorr_check$acf[2]  # First element is lag-0 (always 1)"},{"path":"https://bbuchsbaum.github.io/fmriAR/reference/compat.html","id":null,"dir":"Reference","previous_headings":"","what":"fmrireg compatibility interface — compat","title":"fmrireg compatibility interface — compat","text":"Stable entry points help upstream packages reuse fmriAR whitening without rewriting existing pipelines.","code":""},{"path":"https://bbuchsbaum.github.io/fmriAR/reference/compat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"fmrireg compatibility interface — compat","text":"","code":"compat"},{"path":"https://bbuchsbaum.github.io/fmriAR/reference/compat.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"fmrireg compatibility interface — compat","text":"object class list length 5.","code":""},{"path":"https://bbuchsbaum.github.io/fmriAR/reference/compat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"fmrireg compatibility interface — compat","text":"list environment containing compatibility functions: plan_from_phi: Create whitening plan AR coefficients whiten_with_phi: Apply whitening given AR coefficients update_plan: Update existing plan new residuals plan_info: Extract information plan object whiteness_score: Compute whiteness metric residuals","code":""},{"path":"https://bbuchsbaum.github.io/fmriAR/reference/compat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"fmrireg compatibility interface — compat","text":"","code":"# Create compatibility interface compat_funcs <- compat  # Example: Create whitening plan from AR coefficients phi <- c(0.3, 0.1)  # AR(2) coefficients plan <- compat_funcs$plan_from_phi(phi, exact_first = TRUE) #> Warning: no non-missing arguments to max; returning -Inf  # Example: Compute whiteness score resid <- matrix(rnorm(100 * 10), 100, 10) score <- compat_funcs$whiteness_score(resid)"},{"path":"https://bbuchsbaum.github.io/fmriAR/reference/fit_noise.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit an AR/ARMA noise model (run-aware) and return a whitening plan — fit_noise","title":"Fit an AR/ARMA noise model (run-aware) and return a whitening plan — fit_noise","text":"Fit AR/ARMA noise model (run-aware) return whitening plan","code":""},{"path":"https://bbuchsbaum.github.io/fmriAR/reference/fit_noise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit an AR/ARMA noise model (run-aware) and return a whitening plan — fit_noise","text":"","code":"fit_noise(   resid = NULL,   Y = NULL,   X = NULL,   runs = NULL,   method = c(\"ar\", \"arma\"),   p = \"auto\",   q = 0L,   p_max = 6L,   exact_first = c(\"ar1\", \"none\"),   pooling = c(\"global\", \"run\", \"parcel\"),   parcels = NULL,   parcel_sets = NULL,   multiscale = c(\"pacf_weighted\", \"acvf_pooled\"),   ms_mode = NULL,   p_target = NULL,   beta = 0.5,   hr_iter = 0L,   step1 = c(\"burg\", \"yw\"),   parallel = FALSE )"},{"path":"https://bbuchsbaum.github.io/fmriAR/reference/fit_noise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit an AR/ARMA noise model (run-aware) and return a whitening plan — fit_noise","text":"resid Numeric matrix (time x voxels) residuals initial OLS fit. Y Optional data matrix used compute residuals resid omitted. X Optional design matrix used Y compute residuals. runs Optional integer vector run identifiers. method Either \"ar\" \"arma\". p AR order (integer \"auto\" method == \"ar\"). q MA order (integer). p_max Maximum AR order p = \"auto\". exact_first Apply exact AR(1) scaling segment starts (\"ar1\" \"none\"). pooling Combine parameters across runs parcels (\"global\", \"run\", \"parcel\"). parcels Integer vector (length = ncol(resid)) giving fine parcel memberships pooling = \"parcel\". parcel_sets Optional named list entries coarse, medium, fine equal length specifying nested parcel labels multi-scale pooling. multiscale Multi-scale pooling mode parcel_sets supplied (\"pacf_weighted\" \"acvf_pooled\"), TRUE/FALSE toggle pooling. ms_mode Explicit multiscale mode multiscale logical. p_target Target AR order multi-scale pooling (defaults p_max). beta Size exponent multi-scale weights (default 0.5). hr_iter Number Hannan–Rissanen refinement iterations ARMA. step1 Preliminary high-order AR fit method HR (\"burg\" \"yw\"). parallel Reserved future parallel estimation (logical).","code":""},{"path":"https://bbuchsbaum.github.io/fmriAR/reference/fit_noise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit an AR/ARMA noise model (run-aware) and return a whitening plan — fit_noise","text":"object class fmriAR_plan used whiten_apply().","code":""},{"path":"https://bbuchsbaum.github.io/fmriAR/reference/fit_noise.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit an AR/ARMA noise model (run-aware) and return a whitening plan — fit_noise","text":"","code":"# Generate example data with AR(1) structure n_time <- 200 n_voxels <- 50 phi_true <- 0.5  # Simulate residuals with AR(1) structure resid <- matrix(0, n_time, n_voxels) for (v in 1:n_voxels) {   e <- rnorm(n_time)   resid[1, v] <- e[1]   for (t in 2:n_time) {     resid[t, v] <- phi_true * resid[t-1, v] + e[t]   } }  # Fit AR model plan <- fit_noise(resid, method = \"ar\", p = 1)  # With multiple runs runs <- rep(1:2, each = 100) plan_runs <- fit_noise(resid, runs = runs, method = \"ar\", pooling = \"run\")"},{"path":"https://bbuchsbaum.github.io/fmriAR/reference/fmriAR-package.html","id":null,"dir":"Reference","previous_headings":"","what":"fmriAR: Fast AR/ARMA Prewhitening for fMRI Design and Data — fmriAR-package","title":"fmriAR: Fast AR/ARMA Prewhitening for fMRI Design and Data — fmriAR-package","text":"Lightweight utilities estimate AR/ARMA noise models residuals apply matched GLS prewhitening fMRI design data matrices. Run-aware censor-aware; small exported surface; C++ core speed. Estimate AR/ARMA noise models residuals apply matched GLS prewhitening fMRI design data matrices. Run-aware censor-aware.","code":""},{"path":"https://bbuchsbaum.github.io/fmriAR/reference/fmriAR-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"fmriAR: Fast AR/ARMA Prewhitening for fMRI Design and Data — fmriAR-package","text":"fmriAR package provides efficient implementations : AR ARMA model estimation fMRI residuals Run-aware censor-aware whitening transformations Parcel-based parameter pooling Sandwich standard error computation","code":""},{"path":[]},{"path":"https://bbuchsbaum.github.io/fmriAR/reference/fmriAR-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"fmriAR: Fast AR/ARMA Prewhitening for fMRI Design and Data — fmriAR-package","text":"Maintainer: Name @example.com","code":""},{"path":"https://bbuchsbaum.github.io/fmriAR/reference/sandwich_from_whitened_resid.html","id":null,"dir":"Reference","previous_headings":"","what":"GLS standard errors from whitened residuals — sandwich_from_whitened_resid","title":"GLS standard errors from whitened residuals — sandwich_from_whitened_resid","text":"GLS standard errors whitened residuals","code":""},{"path":"https://bbuchsbaum.github.io/fmriAR/reference/sandwich_from_whitened_resid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GLS standard errors from whitened residuals — sandwich_from_whitened_resid","text":"","code":"sandwich_from_whitened_resid(   Xw,   Yw,   beta = NULL,   type = c(\"iid\", \"hc0\"),   df_mode = c(\"rankX\", \"n-p\"),   runs = NULL )"},{"path":"https://bbuchsbaum.github.io/fmriAR/reference/sandwich_from_whitened_resid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GLS standard errors from whitened residuals — sandwich_from_whitened_resid","text":"Xw Whitened design matrix. Yw Whitened data matrix (time x voxels). beta Optional coefficients (p x v); estimated NULL. type Either \"iid\" (default) \"hc0\" robust sandwich. df_mode Degrees--freedom mode: \"rankX\" (default) \"n-p\". runs Optional run labels (reserved future per-run scaling).","code":""},{"path":"https://bbuchsbaum.github.io/fmriAR/reference/sandwich_from_whitened_resid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"GLS standard errors from whitened residuals — sandwich_from_whitened_resid","text":"List containing standard errors, innovation variances, XtX inverse.","code":""},{"path":"https://bbuchsbaum.github.io/fmriAR/reference/sandwich_from_whitened_resid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"GLS standard errors from whitened residuals — sandwich_from_whitened_resid","text":"","code":"# Generate example whitened data n_time <- 200 n_pred <- 3 n_voxels <- 50 Xw <- matrix(rnorm(n_time * n_pred), n_time, n_pred) Yw <- matrix(rnorm(n_time * n_voxels), n_time, n_voxels)  # Compute standard errors se_result <- sandwich_from_whitened_resid(Xw, Yw, type = \"iid\")  # Extract standard errors for first voxel se_voxel1 <- se_result$se[, 1]"},{"path":"https://bbuchsbaum.github.io/fmriAR/reference/whiten.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit and apply whitening in one call — whiten","title":"Fit and apply whitening in one call — whiten","text":"Fit apply whitening one call","code":""},{"path":"https://bbuchsbaum.github.io/fmriAR/reference/whiten.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit and apply whitening in one call — whiten","text":"","code":"whiten(X, Y, runs = NULL, censor = NULL, ...)"},{"path":"https://bbuchsbaum.github.io/fmriAR/reference/whiten.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit and apply whitening in one call — whiten","text":"X Design matrix (time x regressors). Y Data matrix (time x voxels). runs Optional run labels. censor Optional censor indices. ... Additional parameters passed fit_noise().","code":""},{"path":"https://bbuchsbaum.github.io/fmriAR/reference/whiten.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit and apply whitening in one call — whiten","text":"List whitened X Y matrices.","code":""},{"path":"https://bbuchsbaum.github.io/fmriAR/reference/whiten.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit and apply whitening in one call — whiten","text":"","code":"# Create example data n_time <- 200 n_pred <- 3 n_voxels <- 50 X <- matrix(rnorm(n_time * n_pred), n_time, n_pred) Y <- X %*% matrix(rnorm(n_pred * n_voxels), n_pred, n_voxels) +      matrix(rnorm(n_time * n_voxels, sd = 2), n_time, n_voxels)  # One-step whitening whitened <- whiten(X, Y, method = \"ar\", p = 2)"},{"path":"https://bbuchsbaum.github.io/fmriAR/reference/whiten_apply.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply a whitening plan to design and data matrices — whiten_apply","title":"Apply a whitening plan to design and data matrices — whiten_apply","text":"Apply whitening plan design data matrices","code":""},{"path":"https://bbuchsbaum.github.io/fmriAR/reference/whiten_apply.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply a whitening plan to design and data matrices — whiten_apply","text":"","code":"whiten_apply(   plan,   X,   Y,   runs = NULL,   run_starts = NULL,   censor = NULL,   parcels = NULL,   inplace = FALSE,   parallel = TRUE )"},{"path":"https://bbuchsbaum.github.io/fmriAR/reference/whiten_apply.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply a whitening plan to design and data matrices — whiten_apply","text":"plan Whitening plan fit_noise(). X Numeric matrix predictors (time x regressors). Y Numeric matrix data (time x voxels). runs Optional run labels. run_starts Optional 0-based run start indices (alternative runs). censor Optional indices censored TRs (1-based); filter resets gaps. parcels Optional parcel labels (length = ncol(Y)) using parcel plans. inplace Modify inputs place (logical). parallel Use OpenMP parallelism available.","code":""},{"path":"https://bbuchsbaum.github.io/fmriAR/reference/whiten_apply.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply a whitening plan to design and data matrices — whiten_apply","text":"List whitened data. Parcel plans return X_by per parcel; others return single X matrix.","code":""},{"path":"https://bbuchsbaum.github.io/fmriAR/reference/whiten_apply.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply a whitening plan to design and data matrices — whiten_apply","text":"","code":"# Create example design matrix and data n_time <- 200 n_pred <- 3 n_voxels <- 50 X <- matrix(rnorm(n_time * n_pred), n_time, n_pred) Y <- X %*% matrix(rnorm(n_pred * n_voxels), n_pred, n_voxels) +      matrix(rnorm(n_time * n_voxels), n_time, n_voxels)  # Fit noise model from residuals residuals <- Y - X %*% solve(crossprod(X), crossprod(X, Y)) plan <- fit_noise(residuals, method = \"ar\", p = 2)  # Apply whitening whitened <- whiten_apply(plan, X, Y) Xw <- whitened$X Yw <- whitened$Y"}]
